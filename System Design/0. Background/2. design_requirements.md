**2. DESIGN REQUIREMENTS PART 1**
------------------------------------------------------------
* Make a robust and reliable system.
    - performance
    - security
* What makes a Good Design.
    - Scalability
        > Our system growth with its user base.
    - Maintainability
        > ensuring future developers can understand and improve our system.
    - Efficiency
        > making the best use of our resources
    - Reliability
        >* planning for failure
        >* building a system that maintains its composure when things go wrong.
* Heart of system Design
    1. Moving Data
        * ensuring data can flow seamlessly from one part of our system to another.
            >* user requests seeding servers.
            >* data transfers between databases.
        * Speed and security.
    2. Storing Data
        * access Patterns.
        * indexing strategies.
        * backup solutions.
        * Data needs to be stored securely and readily available when needed.
    3. Transforming Data.
        * taking raw data and turning it into meaningful information.
            >* aggragating log files for analysis.
            >* converting user input into a different format.
* CAP Theorem (Brewer's Theorem)
    - Consistency, Availability, Partition Tolerance
        1. Consistency
            * all nodes in distributed system have the same data at the same time.
                >* make a change in one node it should be reflected in all nodes. 
        2. Availability
            * the system is always operational and responsive to requests 
            * regardless of whats happening behind the scenes.
            * systems operational performance and reliability.
                - is our system up and running when our users need it.
                - measured in terms of percentage aiming for 99.999
                    >* 99.9% availability   -> 8.76 hours of downtime.
                    >* 99.999% availability -> 5 minutes of downtime.
                - Service Level Objectives
                    >* setting goals for our systems performance and availability.
                    >* `example: service should respond to a request within 300 milliseconds 99.9% of time.` 
                - Service Level Agreements
                    >* formal contracts with our users or customers.
                    >* define minimum level of service we are committing to provide.
                - Resilence: expect the unexpected.
                    * implement redundant systems (ensuring there is a backup)
                    * allow system to degrade gracefully, even if certain features arent available, core functionality stays intact.
                    * to measure this we use reliability, fault tolerance and redundancy.
                        >* reliability: ensuring our system works correctly and consistently
                        >* fault tolerance: preparing for when things go wrong, how does our system handle unexpected failures or attacks.
                        >* redundancy: ensuring we have backups, if one part of system fails, there is another ready to take its place.
        3. Partition Tolerance
            * refers to systems ability to keep functionaing even when a network partition occurs.
            * if there is a disruption in communication between nodes, the system still works.
    - You can only achieve two out of these three properties at the same time.
        - not about finding the perfect solution, its about finding the best solution for our specific use case\
        - making informed decision about where we can afford to compromise.
* Speed of System (Throughput and Latency)
    1. Throughput: how much data our system can handle over a certain period of time.
        - Server Throughput:   measured in (requests per second)
        - Database Throughput: measured in (queries per second)
        - Data Throughput:     measured in (bytes per second) 
    2. Latency: how long it takes to handle a single request (time it takes for a request to get a response).

**2. DESIGN REQUIREMENTS PART 2**
------------------------------------------------------------
* Types of Requirements in System Design
    1. Functional Requirements
        - define the specific behaviors or functions that a system must perform.
        - tells how the system should respond to various inputs and how it behaves in different situations.
            >* user stories or use cases.
            >* serve as the foundation for system design and development.
        - essential for ensuring that system meets intended purpose and delivers expected functionality to users.
        - examples:
            >* User Registration: Allow users to create new accounts by providing their name, email address, and password.
            >* User Profile: Enable users to update their profile information, including their profile picture, bio, and contact information.
            >* Friend Connections: Enable users to send and accept friend requests, and manage their list of friends.
            >* Post Creation: Allow users to create new posts, including text, images, and videos, and share them with friends or publicly.
            >* Privacy Settings: Provide users with the ability to control the privacy settings of their posts and profile.
            >* Messaging: Enable users to send private messages to other users and participate in group chats.
            >* Notifications: Notify users about new friend requests, messages, and interactions on their posts.
            >* Search Functionality: Allow users to search for other users, posts, and content within the platform.
    2. Non-Functional Requirements
        - specify the quality attributes or constraints that the system must satisfy.
        - define how well the system performs certain functions rather than what functions it performs.
        - include aspects such as performance, reliability, security, usability, and scalability.
        - are critical for ensuring that the system meets the desired level of quality and can be effectively used in its intended environment.
        - examples:
            >* Performance: The system should be able to handle a minimum of 1000 concurrent users without experiencing significant slowdowns.
            >* Reliability: The system should have a uptime of at least 99.9% to ensure users can access it whenever they need.
            >* Security: The system should implement secure authentication mechanisms, such as HTTPS, to protect user data from unauthorized access.
            >* Usability: The user interface should be intuitive and easy to navigate, with clear labeling and consistent design elements.
            >* Scalability: The system should be able to scale horizontally to accommodate an increase in users and data volume without significant changes to the architecture.
            >* Availability: The system should be available 24/7, with scheduled maintenance windows communicated to users in advance.
    3. Extended Requirements
        -  encompass a broader range of considerations that may not fit neatly into the categories of functional or non-functional requirements.
        - include additional aspects of the system that are important for its overall success but may not directly relate to its functionality or quality attributes.
        - include regulatory compliance, legal requirements, budget constraints, and environmental considerations.
        - examples:
            >* Regulatory Compliance: Ensure that the platform complies with all relevant laws and regulations, such as data protection laws (e.g., GDPR, CCPA) and content moderation laws (e.g., DMCA).
            >* Legal Requirements: Address any legal considerations specific to the platform, such as user agreements, terms of service, and intellectual property rights.
            >* Budget Constraints: Adhere to budget constraints for the development, maintenance, and operation of the platform, including considerations for cost-effective solutions.
            >* Environmental Considerations: Minimize the environmental impact of the platform, such as energy consumption and carbon footprint, through efficient design and operation.
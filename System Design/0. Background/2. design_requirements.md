## 2. DESIGN REQUIREMENTS PART 1

### Make a robust and reliable system.
- performance
- security
### What makes a Good Design.
- **Scalability**
    > Our system growth with its user base.
- **Maintainability**
    > ensuring future developers can understand and improve our system.
- **Efficiency**
    > making the best use of our resources
- **Reliability**
    >* planning for failure
    >* building a system that maintains its composure when things go wrong.
### Heart of system Design
1. **Moving Data**
    * ensuring data can flow seamlessly from one part of our system to another.
        >* user requests seeding servers.
        >* data transfers between databases.
    * Speed and security.
2. **Storing Data**
    * access Patterns.
    * indexing strategies.
    * backup solutions.
    * Data needs to be stored securely and readily available when needed.
3. **Transforming Data.**
    * taking raw data and turning it into meaningful information.
        >* aggragating log files for analysis.
        >* converting user input into a different format.
### CAP Theorem (Brewer's Theorem)
- Consistency, Availability, Partition Tolerance
    1. **Consistency**
        * all nodes in distributed system have the same data at the same time.
            >* make a change in one node it should be reflected in all nodes. 
    2. **Availability**
        * the system is always operational and responsive to requests 
        * regardless of whats happening behind the scenes.
        * systems operational performance and reliability.
            - is our system up and running when our users need it.
            - measured in terms of percentage aiming for `99.999`
                >* `99.9%` availability   -> `8.76` hours of downtime.
                >* `99.999%` availability -> `5` minutes of downtime.
            - Service Level Objectives
                >* setting goals for our systems performance and availability.
                >* `example: service should respond to a request within 300 milliseconds 99.9% of time.` 
            - Service Level Agreements
                >* formal contracts with our users or customers.
                >* define minimum level of service we are committing to provide.
            - Resilence: expect the unexpected.
                * implement redundant systems (ensuring there is a backup)
                * allow system to degrade gracefully, even if certain features arent available, core functionality stays intact.
                * to measure this we use reliability, fault tolerance and redundancy.
                    >* reliability: ensuring our system works correctly and consistently
                    >* fault tolerance: preparing for when things go wrong, how does our system handle unexpected failures or attacks.
                    >* redundancy: ensuring we have backups, if one part of system fails, there is another ready to take its place.
    3. **Partition Tolerance**
        * refers to systems ability to keep functionaing even when a network partition occurs.
        * if there is a disruption in communication between nodes, the system still works.
- You can only achieve two out of these three properties at the same time.
    - not about finding the perfect solution, its about finding the best solution for our specific use case\
    - making informed decision about where we can afford to compromise.
### Speed of System (Throughput and Latency)
1. **Throughput**: how much data our system can handle over a certain period of time.
    - **Server Throughput:**   measured in (requests per second)
    - **Database Throughput:** measured in (queries per second)
    - **Data Throughput:**     measured in (bytes per second) 
2. **Latency**: how long it takes to handle a single request (time it takes for a request to get a response).

-------------------------------------------------------------------------------------------------------------------------------------------
## 2. DESIGN REQUIREMENTS PART 2
### Types of Requirements in System Design
#### Functional Requirements
- define the specific behaviors or functions that a system must perform.
- tells how the system should respond to various inputs and how it behaves in different situations.
    * user stories or use cases.
    * serve as the foundation for system design and development.
- essential for ensuring that system meets intended purpose and delivers expected functionality to users.
- examples:
    * **User Registration**: Allow users to create new accounts by providing their name, email address, and password.
    * **User Profile**: Enable users to update their profile information, including their profile picture, bio, and contact information.
    * **Friend Connections**: Enable users to send and accept friend requests, and manage their list of friends.
    * **Post Creation**: Allow users to create new posts, including text, images, and videos, and share them with friends or publicly.
    * **Privacy Settings**: Provide users with the ability to control the privacy settings of their posts and profile.
    * **Messaging**: Enable users to send private messages to other users and participate in group chats.
    * **Notifications**: Notify users about new friend requests, messages, and interactions on their posts.
    * **Search Functionality**: Allow users to search for other users, posts, and content within the platform.
#### Non-Functional Requirements
- specify the quality attributes or constraints that the system must satisfy.
- define how well the system performs certain functions rather than what functions it performs.
- include aspects such as performance, reliability, security, usability, and scalability.
- are critical for ensuring that the system meets the desired level of quality and can be effectively used in its intended environment.
- examples:
    * **Performance**: The system should be able to handle a minimum of 1000 concurrent users without experiencing significant slowdowns.
    * **Reliability**: The system should have a uptime of at least 99.9% to ensure users can access it whenever they need.
    * **Security**: The system should implement secure authentication mechanisms, such as HTTPS, to protect user data from unauthorized access.
    * **Usability**: The user interface should be intuitive and easy to navigate, with clear labeling and consistent design elements.
    * **Scalability**: The system should be able to scale horizontally to accommodate an increase in users and data volume without significant changes to the architecture.
    * **Availability**: The system should be available 24/7, with scheduled maintenance windows communicated to users in advance.
#### Extended Requirements
-  encompass a broader range of considerations that may not fit neatly into the categories of functional or non-functional requirements.
- include additional aspects of the system that are important for its overall success but may not directly relate to its functionality or quality attributes.
- include regulatory compliance, legal requirements, budget constraints, and environmental considerations.
- examples:
    * **Regulatory Compliance**: Ensure that the platform complies with all relevant laws and regulations, such as data protection laws (e.g., GDPR, CCPA) and content moderation laws (e.g., DMCA).
    * **Legal Requirements**: Address any legal considerations specific to the platform, such as user agreements, terms of service, and intellectual property rights.
    * **Budget Constraints**: Adhere to budget constraints for the development, maintenance, and operation of the platform, including considerations for cost-effective solutions.
    * **Environmental Considerations**: Minimize the environmental impact of the platform, such as energy consumption and carbon footprint, through efficient design and operation.

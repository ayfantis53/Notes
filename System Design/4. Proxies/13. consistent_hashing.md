## 13. CONSISTENT HASHING PART 1

### What is hashing?
- The classic hashing approach uses a hash function to generate a `pseudo-random` number.
- which is then divided by the size of the memory space to transform the random identifier into a position within the available space.
- Why use hashing?
    * Using a hash function ensures that resources required by computer programs are efficiently stored in memory
    * that in-memory data structures are loaded evenly to make information retrieval more efficient.
- Hashing in a distributed system
    * In a scenario where various programs, computers, or users request resources from multiple server nodes.
    * we need a mechanism to map requests evenly to available server nodes.
    * thus ensuring that the load is balanced for consistent performance.
    * In the classic hashing method, we always assume that:
        - The number of memory locations is known.
        - This number never changes.
    * It’s common for a cluster to scale up and down, and there are always unexpected failures in a distributed system.
    * We cannot guarantee that the number of server nodes will remain the same. 
    * What if one of them fails? 
        - With `a naive hashing approach`, we need to rehash every single key as the new mapping is dependent on the number of nodes and memory locations.
- The problem in a `distributed system` with `simple rehashing` —moving the placement of every key — is that state is stored on each node. A small change in the cluster size could result in a reshuffle of all the data in the cluster. As the cluster size grows, this becomes unsustainable because the amount of work required for each hash change grows linearly with cluster size.

### What is consistent hashing?
- **Consistent hashing** can be described as follows:
    1. It represents the resource requestors (which I shall refer to as `requests`) and the server nodes in a virtual ring structure known as a `hashring`.
    2. The number of locations is no longer fixed, but the ring is considered to have an infinite number of points, and the server nodes can be placed at random locations on this ring. (Of course, choosing this random number again can be done using a hash function, but the second step of dividing it by the number of available locations is skipped as it is no longer a finite number).
    3. The requests, that is, the users, computers or serverless programs, which are analogous to keys in the classic hashing approach, are also placed on the same ring using the same hash function.
- How does consistent hashing work?
    1. Now, what if one of these server nodes fails, say Node 3, the range of the next server node widens and any request coming in all of this range, goes to the new server node.
    2. But that’s it. It’s just this one range, corresponding to the failed server node, that needed to be re-assigned, while the rest of the hashring and request-node assignments still remain unaffected.
    3. Contrast this with the classic hashing technique in which a change in size of the hash table effectively disturbs ALL of the mappings. Thanks to consistent hashing, only a portion (relative to the ring distribution factor) of the requests will be affected by a given ring change. (A ring change occurs due to an addition or removal of a node causing some of the request-node mappings to change.)

### How to implement a consistent hashing algorithm?
- Now that we’re comfortable with what a hash ring is, we need to implement a `mapping` from our hash space to nodes in the cluster to find the nodes responsible for a given request.
- We need a hash function to compute the position in the ring given an identifier for requests. We also need a way to determine which node corresponds to a hashed request. For this, we can use a simple data structure that comprises the following:
    * An array of hashes that correspond to nodes in the ring.
    * A map (`hash table`) for finding the node corresponding to a particular request.
- This is essentially a primitive representation of an ordered map.
- To find a node responsible for a given hash in the above structure, we need to:
    * Perform a modified binary search to find the first node-hash in the array that is equal to or greater than `(≥)` the hash you wish to look up.
    * Look up the node corresponding to the found node-hash in the map.
- Addition or removal of a node
    * As I explained at the beginning of the article, when a new node is added, some portion of the hashring, comprising of various requests, must be assigned to that node. 
    * Conversely, when a node is removed, the requests that had been assigned to that node will need to be handled by some other node.
- How to manage a ring change

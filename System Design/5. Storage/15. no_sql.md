**15. NO SQL PART 1**
------------------------------------------------------------
- are non-relational databases that store data in a variety of flexible formats rather than in the rigid, tabular structure of traditional SQL databases.
    * > common types:
        1. key-value pairs
        2. Columnar (or wide-column) databases
        3. documents
        4. graphs
- They are designed for large-scale data, high performance, and horizontal scalability.
- making them ideal for applications like 
    * > AI 
    * > IoT
    * > web-scale systems
- Key characteristics and benefits
    1. [Flexible-schema]: 
        - NoSQL databases can handle unstructured and semi-structured data without requiring a predefined schema. 
        - which simplifies development and allows for faster iteration.
    2. [Scalability]: 
        - They use horizontal scaling, distributing data across multiple servers.
        - which allows them to handle massive amounts of data and traffic more efficiently than vertical scaling alone.
    3. [Performance]: 
        - They are optimized for specific data models and can provide fast query performance by avoiding complex joins.
        - which are common in relational databases.
    4. [High-availability]: 
        - Many are designed to be highly available, often by replicating data across multiple nodes.
        - which helps prevent downtime. 
- Types of NoSQL databases
    1. [Document-databases]: 
        - Store data in documents, typically in a format like JSON or XML, which can be nested. 
        - They are good for applications where data can be naturally represented as a document. 
        - like a user profile or product catalog.
    2. [Key-value-stores]: 
        - The simplest type, storing data as a collection of key-value pairs. 
        - They are excellent for high-speed data retrieval when the key is known, such as in caching.
    3. [Columnar-(or-wide-column)-databases]: 
        - Store data in columns rather than rows. 
        - This is efficient for querying large datasets with a large number of columns.
        -  especially when you only need to access a few columns at a time.
    4. [Graph-databases]: 
        - Use nodes and edges to represent and store data with complex relationships.
        - such as social networks or recommendation engines. 
- When to use NoSQL
    * > When you need to handle large volumes of rapidly changing or unstructured data.
    * > When high availability & horizontal scalability are more critical than complex queries and strict consistency guarantees.
    * > For modern applications like those using AI, IoT, and real-time data analytics.
- When to consider other options
    * > If your application requires complex queries and joins across multiple tables with strong referential integrity.
    * > If you need strict ACID (Atomicity, Consistency, Isolation, Durability) transactions for every operation, as not all NoSQL databases provide this, though some modern ones do. 
- BASE compliance
    1. [Basic-availability] 
        - refers to the ability of the system to tolerate a partial failure (like a loss of a node).
    2. [Soft-state]
        - means that the system allows temporary inconsistencies before eventually achieving consistency automatically over time.
    * BASE compliance ensures high availability, faster data processing, scalability, and flexibility. However, MongoDB can also be configured to provide multi-document ACID compliance.
- Differences between RDBMS and NoSQL databases
    1. [Data-modeling]
        - `NoSQL`: Data models vary based on the type of NoSQL database used — for example, key-value, document, graph, and wide-column — making the model suitable for semi-structured and unstructured data.
        - `RDBMS`: RDBMS uses a tabular data structure, with data represented as a set of rows and columns, making the model suitable for structured data.
    2. [Schema]
        - `NoSQL`: It provides a flexible schema where each set of documents/row-column/key-value pairs can contain different types of data. It’s easier to change schema, if required, due to the flexibility.
        - `RDBMS`: This is a fixed schema where every row should contain the same predefined column types. It is difficult to change the schema once data is stored.
    3. [Query-language]
        - `NoSQL`: It varies based on the type of NoSQL database used. For example, MongoDB has MQL, and Neo4J uses Cypher.
        - `RDBMS`: This uses structured query language (SQL).
    4. [Scalability]
        - `NoSQL`: NoSQL is designed for vertical and horizontal scaling.
        - `RDBMS`: RDBMS is designed for vertical scaling. However, it can extend limited capabilities for horizontal scaling.
    5. [Data-relationships]
        - `NoSQL`: Relationships can be nested, explicit, or implicit.
        - `RDBMS`: Relationships are defined through foreign keys and accessed using joins.
    6. [Transaction-type]
        - `NoSQL`: Transactions are either ACID- or BASE-compliant.
        - `RDBMS`: Transactions are ACID-compliant.
    7. [Performance]
        - `NoSQL`: NoSQL is suitable for real-time processing, big data analytics, and distributed environments.
        - `RDBMS`: RDBMS is suitable for read-heavy and transaction workloads.
    8. [Data-consistency]
        - `NoSQL`: This offers eventual consistency, in most cases.
        - `RDBMS`: This offers high data consistency.
    9. [Distributed-computing]
        - `NoSQL`: One of the main reasons to introduce NoSQL was for distributed computing, and NoSQL databases support distributed data storage, vertical and horizontal scaling through sharding, replication, and clustering.
        - `RDBMS`: RDBMS supports distributed computing through clustering and replication. However, it’s less scalable and flexible as it’s not traditionally designed to support distributed architecture.
    10. [Fault-tolerance]
        - `NoSQL`: NoSQL has built-in fault tolerance and high availability due to data replication.
        - `RDBMS`: RDBMS uses replication, backup, and recovery mechanisms. However, as they are designed for these, additional measures like disaster recovery mechanisms may need to be implemented during application development.
    11. [Data-partitioning]
        - `NoSQL`: It’s done through sharding and replication.
        - `RDBMS`: It supports table-based partitioning and partition pruning.
    12. [Data-to-object-mapping]
        - `NoSQL`: NoSQL stores the data in a variety of ways — for example, as JSON documents, wide-column stores, or key-value pairs. It provides abstraction through the ODM (object-data mapping) frameworks to work with NoSQL data in an object-oriented manner.
        - `RDBMS`: RDBMS relies more on data-to-object mapping so that there is seamless integration between the database columns and the object-oriented application code.
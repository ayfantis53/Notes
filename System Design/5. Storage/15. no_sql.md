## 15. NO SQL PART 1

### are non-relational databases that store data in a variety of flexible formats rather than in the rigid, tabular structure of traditional SQL databases.
- common types:
    1. key-value pairs
    2. Columnar (or wide-column) databases
    3. documents
    4. graphs
- They are designed for large-scale data, high performance, and horizontal scalability.

### making them ideal for applications like 
- AI 
- IoT
- web-scale systems

### Key characteristics and benefits
1. **Flexibl -schema**: 
    - `NoSQL` databases can handle `unstructured` and `semi-structured` data without requiring a predefined schema. 
    - which simplifies development and allows for faster iteration.
2. **Scalability**: 
    - They use `horizontal scaling`, distributing data across multiple servers.
    - which allows them to handle massive amounts of data and traffic more efficiently than vertical scaling alone.
3. **Performance**: 
    - They are optimized for specific data models and can provide fast query performance by avoiding complex joins.
    - which are common in relational databases.
4. **High availability**: 
    - Many are designed to be highly available, often by replicating data across multiple nodes.
    - which helps prevent downtime.

### Types of NoSQL databases
1. **Document databases**: 
    - Store data in documents, typically in a format like `JSON` or `XML`, which can be nested. 
    - They are good for applications where data can be naturally represented as a document. 
    - like a user profile or product catalog.
2. **Key value stores**: 
    - The simplest type, storing data as a collection of `key-value pairs`. 
    - They are excellent for high-speed data retrieval when the key is known, such as in caching.
3. **Columnar (or wide column) databases**: 
    - Store data in columns rather than rows. 
    - This is efficient for querying large datasets with a large number of columns.
    -  especially when you only need to access a few columns at a time.
4. **Graph databases**: 
    - Use nodes and edges to represent and store data with complex relationships.
    - such as social networks or recommendation engines. 

### When to use NoSQL
- When you need to handle large volumes of rapidly changing or unstructured data.
- When high `availability` & `horizontal scalability` are more critical than `complex queries` and strict consistency guarantees.
- For modern applications like those using AI, IoT, and real-time data analytics.

### When to consider other options
- If your application requires complex queries and joins across multiple tables with strong referential integrity.
- If you need strict `ACID` (Atomicity, Consistency, Isolation, Durability) transactions for every operation, as not all NoSQL databases provide this, though some modern ones do. 

### BASE compliance
1. **Basic availability** 
    - refers to the ability of the system to tolerate a partial failure (like a loss of a node).
2. **Soft state**
    - means that the system allows temporary inconsistencies before eventually achieving consistency automatically over time.
- `BASE` compliance ensures high availability, faster data processing, scalability, and flexibility. However, `MongoDB` can also be configured to provide multi-document `ACID` compliance.

### Differences between RDBMS and NoSQL databases
1. **Data modeling**
    - **NoSQL**: 
        * > Data models vary based on the type of NoSQL database used
        * > for example, key-value, document, graph, and wide-column 
        * > making the model suitable for semi-structured and unstructured data.
    - **RDBMS**: 
        * > RDBMS uses a tabular data structure, with data represented as a set of rows and columns.
        * > making the model suitable for structured data.
2. **Schema**
    - **NoSQL**: 
        * > It provides a flexible schema where each set of documents/row-column/key-value pairs can contain different types of data. 
        * > It’s easier to change schema, if required, due to the flexibility.
    - **RDBMS**: 
        * > This is a fixed schema where every row should contain the same predefined column types. 
        * > It is difficult to change the schema once data is stored.
3. **Query language**
    - **NoSQL**: 
        * > It varies based on the type of NoSQL database used. 
        * > For example, MongoDB has MQL, and Neo4J uses Cypher.
    - **RDBMS**: 
        * > This uses structured query language (SQL).
4. **Scalability**
    - **NoSQL**: 
        * > NoSQL is designed for vertical and horizontal scaling.
    - **RDBMS**: 
        * > RDBMS is designed for vertical scaling. 
        * > However, it can extend limited capabilities for horizontal scaling.
5. **Data-relationships**
    - **NoSQL**: 
        * > Relationships can be nested, explicit, or implicit.
    - **RDBMS**: 
        * > Relationships are defined through foreign keys and accessed using joins.
6. **Transaction type**
    - **NoSQL**: 
        * > Transactions are either ACID- or BASE-compliant.
    - **RDBMS**: 
        * > Transactions are ACID-compliant.
7. **Performance**
    - **NoSQL**: 
        * > NoSQL is suitable for real-time processing, big data analytics, and distributed environments.
    - **RDBMS**: 
        * > RDBMS is suitable for read-heavy and transaction workloads.
8. **Data consistency**
    - **NoSQL**: 
        * > This offers eventual consistency, in most cases.
    - **RDBMS**: 
        * > This offers high data consistency.
9. **Distributed computing**
    - **NoSQL**: 
        * > One of the main reasons to introduce NoSQL was for distributed computing, and NoSQL databases support distributed data storage
        * > vertical and horizontal scaling through sharding, replication, and clustering.
    - **RDBMS**: 
        * > RDBMS supports distributed computing through clustering and replication. 
        * > However, it’s less scalable and flexible as it’s not traditionally designed to support distributed architecture.
10. **Fault tolerance**
    - **NoSQL**: 
        * > NoSQL has built-in fault tolerance and high availability due to data replication.
    - **RDBMS**: 
        * > RDBMS uses replication, backup, and recovery mechanisms. 
        * > However, as they are designed for these, additional measures like disaster recovery mechanisms may need to be implemented during application development.
11. **Data partitioning**
    - **NoSQL**: 
        * > It’s done through sharding and replication.
    - **RDBMS**: 
        * > It supports table-based partitioning and partition pruning.
12. **Data to object mapping**
    - **NoSQL**: 
        * > NoSQL stores the data in a variety of ways
        * > for example, as JSON documents, wide-column stores, or key-value pairs. 
        * > It provides abstraction through the ODM (object-data mapping) frameworks to work with NoSQL data in an object-oriented manner.
    - **RDBMS**: 
        * > RDBMS relies more on data-to-object mapping so that there is seamless integration between the database columns and the object-oriented application code.
